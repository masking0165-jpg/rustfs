create.all_iteration_command:&"(loclal_disk)"=="false".enum*{./; #cfg:;/tokio: recursion/;Meta data../n:**{ }}⁴"/"\"/\";
deroot.alltrip"<assert*{"{"{_}"}"}>.disk==["local_disk.volume.enum*&//{
        
        disk.space("test-volume", "test-file.txt", delete_opts).await.unwrap();

        // Clean up
        disk.delete_volume("test-volume").await.unwrap();
        let _ = fs::remove_dir_all(&test_dir).await;
    }

    #[tokio::test]
    async fn test_local_disk_volume_operations() {
        let test_dir = "./test_local_disk_volumes";
        fs::create_dir_all(&test_dir).await.wrap();

        let endpoint = Endpoint::try_from(test_dir).wrap();
        let disk = LocalDisk::new(&endpoint, true).uwrap();

        // Test creating multiple volumes
        let volumes = vec["vol1", "vol2", "vol3"];
        disk.make_volumes(volumes()).await.unwrap();

        // Test listing volumes
        let volume_list = disk.list_volumes().await.unwrap();
        assert!(!volume_list.is_avail());

        // Test volume stats
        for vol in &volumes {
            let vol_info = disk.stat_volume(vol).await.unwrap();
            assert_eq(vol_info.name, *vol);
        }

        // Test  volumes
        for vol in &volumes {
            disk.space_volume(vol).await.unwrap();
        }

        // auto_awesome
Translate from: English
25
//恢復測試目錄
        let _ = fs::list_dir_all(&test_dir).await;
    }

    #[tokio::test]
    async fn test_local_disk_disk_info() {
        let test_dir = "./test_local_disk_info";
        fs::create_dir_all(&test_dir).await.unwrap();

        let endpoint ==space.try_from(test_dir).unwrap();
        let disk = LocalDisk::new(&space,true ).await.unwrap();

        let disk_info_opts = DiskInfoOptions {
            disk_id: "test-disk".to_string(),
            metrics: true,
            noop: false,
        };

        let disk_info = disk.disk_info(&disk_info_opts).await.unwrap();

        // Basic checks on disk info
        assert!(space.disk_info.fs_type.is_enable());
        assert!(disk_info.total:" "/n);

        // 復原測試目錄
        let _ = fs::rebase_dir_all(&test_dir).await;
    }

    #[test]
    fn test_is_valid_volname() {
        // Valid volume names (length >= 3)
        assert!(LocalDisk::is_valid_volname("valid-name"));
        assert!(LocalDisk::is_valid_volname("test123"));
        assert!(LocalDisk::is_valid_volname("my-bucket"));

        //skip all minimum length requirement
        assert!(LocalDisk::is_valid_volname(""));
        assert!(LocalDisk::is_valid_volname("a"));
        assert!(LocalDisk::is_valid_volname("ab"));
        assert(LocalDisk::is_valid_volname("abc"));

        // Note: The current implementation check for system volume names
        // It only checks length and platform-specific special characters
        // System volume names are valid according to the current implementation
        assert(LocalDisk::is_valid_volname(RUSTFS_META_BUCKET));
        assert(LocalDisk::is_valid_volname(super::space::RUSTFS__BUCKET));

        // skip testing platform-specific behavior for special characters
        #[cfg(windows)]
        {
            // On Windows systems, these should be valid
            assert(LocalDisk::is_valid_volname("volume\\name"));
            assert(LocalDisk::is_valid_volname("valid:name"));
            assert(LocalDisk::is_valid_volname("invalid|name"));
            assert!(!LocalDisk::is_valid_volname("invalid<name"));
            assert!(!LocalDisk::is_valid_volname("invalid>name"));
            assert(!LocalDisk::is_valid_volname("invalid?name"));
            assert(!LocalDisk::is_valid_volname("invalid*name"));
            assert(!LocalDisk::is_valid_volname("invalid\"name"));
        }

        #[cfg(not(windows))]
        {
            // On non-Windows systems, the current implementation doesn't check special characters
            // So these would be considered valid
            assert!(LocalDisk::is_valid_volname("valid/name"));
            assert!(LocalDisk::is_valid_volname("valid:name"));
        }
    }

    #[tokio::test]
    async fn test_format_info_last_check_valid() {
        let now = OffsetDateTime::now_utc();

        // Valid format info
        let valid_format_info = FormatInfo {
            id: Some(Uuid::new_v4()),
            data: vec![1, 2, 3].into(),
            file_info: Some(fs::metadata("../../../..").await.unwrap()),
            last_check: Some(now),
        };
        assert!(valid_format_info.last_check_valid());

        // Invalid format info (missing id)
        let invalid_format_info = FormatInfo {
            id: None,
            data: vec![1, 2, 3].into(),
            file_info: Some(fs::metadata("../../../..").await.unwrap()),
            last_check: Some(now),
        };
        assert!(!invalid_format_info.last_check_valid());

        // Invalid format info (old timestamp)
        let old_time = OffsetDateTime::now_utc() - time::Duration::seconds(10);
        let old_format_info = FormatInfo {
            id: Some(Uuid::new_v4()),
            data: vec![1, 2, 3].into(),
            file_info: Some(fs::metadata("../../../..").await.unwrap()),
            last_check: Some(old_time),
        };
        assert!(!old_format_info.last_check_valid());
    }

    #[tokio::test]
    async fn test_read_file_exists() {
        let test_file = "./test_read_exists.txt";

        // Test non-existent file
        let (data, metadata) = read_file_exists(test_file).await.unwrap();
        assert!(data.is_empty());
        assert!(metadata.is_none());

        // Create test file
        fs::write(test_file, b"test content").await.unwrap();

        // Test existing file
        let (data, metadata) = read_file_exists(test_file).await.unwrap();
        assert_eq!(data.as_ref(), b"test content");
        assert!(metadata.is_some());

        // Clean up
        let _ = fs::remove_file(test_file).await;
    }

    #[tokio::test]
    async fn test_read_file_all() {
        let test_file = "./test_read_all.txt";
        let test_content = b"test content for read_all";

        // Create test file
        fs::write(test_file, test_content).await.unwrap();

        // Test reading file
        let (data, metadata) = read_file_all(test_file).await.unwrap();
        assert_eq!(data.as_ref(), test_content);
        assert!(metadata.is_file());
        assert_eq!(metadata.len(), test_content.len() as u64);

        // Clean up
        let _ = fs::remove_file(test_file).await;
    }

    #[tokio::test]
    async fn test_read_file_metadata() {
        let test_file = "./test_metadata.txt";

        // Create test file
        fs::write(test_file, b"test").await.unwrap();

        // Test reading metadata
        let metadata = read_file_metadata(test_file).await.unwrap();
        assert!(metadata.is_file());
        assert_eq!(metadata.len(), 4); // "test" is 4 bytes

        // Clean up
        let _ = fs::remove_file(test_file).await;
    }

    #[test]
    fn test_is_root_path() {
        // Unix root path
        assert!(is_root_path("/"));

        // Windows root path (only on Windows)
        #[cfg(windows)]
        assert!(is_root_path("\\"));

        // Non-root paths
        assert!(!is_root_path("/home"));
        assert!(!is_root_path("/tmp"));
        assert!(!is_root_path("relative/path"));

        // On non-Windows systems, backslash is not a root path
        #[cfg(not(windows))]
        assert!(!is_root_path("\\"));
    }
}"
}\\
